Spring Framework - Dependency Injection (DI):

Dependency Injection Overview: Spring Framework offers a core feature called Dependency Injection (DI), which allows the framework to manage the creation, configuration, and lifecycle of objects (beans). Instead of the programmer manually creating objects using the new keyword and managing their lifecycle, Spring takes care of this, reducing boilerplate code and improving modularity.

Spring Container: When an application is run, Spring creates a Spring Container (often referred to as ApplicationContext). This container is responsible for managing beans (objects), ensuring they are created and wired together based on configuration, whether via annotations, XML, or Java-based configuration.

Using @Component Annotation: To inform Spring that it should manage an object, you can annotate the class with @Component. This tells Spring to automatically create and manage the object, making it available in the application context.

Getting Beans from the Container: Once the Spring container is initialized, you can retrieve beans using ApplicationContext. For example:
ProductService productService = context.getBean(ProductService.class);
Here, context.getBean() fetches the ProductService object that Spring has already created and managed.


Spring Data JPA - Simplified Database Interaction:

Creating Database Interaction Layer: In Spring, instead of manually creating classes to manage database queries, you can use Spring Data JPA to simplify this process.

Interface Instead of Class: Instead of creating a traditional class for database operations, you create an interface. This interface will extend JpaRepository, which provides a powerful abstraction for database operations.

Defining the Repository Interface:
public interface ProductRepository extends JpaRepository<Product, Integer> {
    // No additional code required
}
Product: The entity class that this repository will manage.
Integer: The data type of the entity's primary key.

Automatic Method Implementation: By extending JpaRepository, you gain access to various CRUD operations like findAll(), save(), deleteById(), etc., without writing any SQL queries. Spring Data JPA automatically provides the implementation.

Using the Repository:
@Autowired
private ProductRepository productRepository;
// Example usage
List<Product> products = productRepository.findAll();

Here, findAll() retrieves all records from the Product table without writing any SQL code.
Behind the Scenes: While you don't write SQL queries, Spring Data JPA generates them dynamically based on method names and annotations. This approach streamlines database interactions and reduces the amount of boilerplate code.


application.properties in resources folder should be updated for db connection